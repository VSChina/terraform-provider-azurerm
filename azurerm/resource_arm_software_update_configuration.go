// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file at
//     https://github.com/Azure/magic-module-specs
//
// ----------------------------------------------------------------------------

package azurerm

import (
	"fmt"
	"log"
	"time"

	"github.com/Azure/go-autorest/autorest/date"
	"github.com/hashicorp/terraform/helper/schema"
	"github.com/hashicorp/terraform/helper/validation"
	"github.com/terraform-providers/terraform-provider-azurerm/azurerm/helpers/azure"
	"github.com/terraform-providers/terraform-provider-azurerm/azurerm/helpers/tf"
	"github.com/terraform-providers/terraform-provider-azurerm/azurerm/helpers/validate"
)

func resourceArmSoftwareUpdateConfiguration() *schema.Resource {
	return &schema.Resource{
		Create: resourceArmSoftwareUpdateConfigurationCreateUpdate,
		Read:   resourceArmSoftwareUpdateConfigurationRead,
		Update: resourceArmSoftwareUpdateConfigurationCreateUpdate,
		Delete: resourceArmSoftwareUpdateConfigurationDelete,

		Importer: &schema.ResourceImporter{
			State: schema.ImportStatePassthrough,
		},

		Schema: map[string]*schema.Schema{
			"name": {
				Type:         schema.TypeString,
				Required:     true,
				ForceNew:     true,
				ValidateFunc: validate.NoEmptyStrings,
			},

			"name": {
				Type:     schema.TypeString,
				Computed: true,
			},

			"resource_group": azure.SchemaResourceGroupNameDiffSuppress(),

			"automation_account_name": {
				Type:         schema.TypeString,
				Required:     true,
				ForceNew:     true,
				ValidateFunc: validate.NoEmptyStrings,
			},

			"schedule_info": {
				Type:     schema.TypeList,
				Required: true,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"advanced_schedule": {
							Type:     schema.TypeList,
							Optional: true,
							MaxItems: 1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"month_days": {
										Type:     schema.TypeInt,
										Optional: true,
									},
									"monthly_occurrences": {
										Type:     schema.TypeList,
										Optional: true,
										MaxItems: 1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"day": {
													Type:     schema.TypeString,
													Optional: true,
													ValidateFunc: validation.StringInSlice([]string{
														string(automation.Monday),
														string(automation.Tuesday),
														string(automation.Wednesday),
														string(automation.Thursday),
														string(automation.Friday),
														string(automation.Saturday),
														string(automation.Sunday),
													}, false),
													Default: string(automation.Monday),
												},
												"occurrence": {
													Type:     schema.TypeInt,
													Optional: true,
												},
											},
										},
									},
									"week_days": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},
						"creation_time": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: validateRFC3339Date,
						},
						"description": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"expiry_time": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: validateRFC3339Date,
						},
						"expiry_time_offset_minutes": {
							Type:     schema.TypeInt,
							Optional: true,
						},
						"frequency": {
							Type:     schema.TypeString,
							Optional: true,
							ValidateFunc: validation.StringInSlice([]string{
								string(automation.OneTime),
								string(automation.Day),
								string(automation.Hour),
								string(automation.Week),
								string(automation.Month),
								string(automation.Minute),
							}, false),
							Default: string(automation.OneTime),
						},
						"interval": {
							Type:     schema.TypeInt,
							Optional: true,
						},
						"is_enabled": {
							Type:     schema.TypeBool,
							Optional: true,
						},
						"last_modified_time": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: validateRFC3339Date,
						},
						"next_run": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: validateRFC3339Date,
						},
						"next_run_offset_minutes": {
							Type:     schema.TypeInt,
							Optional: true,
						},
						"start_time": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: validateRFC3339Date,
						},
						"time_zone": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"update_configuration": {
				Type:     schema.TypeList,
				Required: true,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"operating_system": {
							Type:     schema.TypeString,
							Required: true,
							ValidateFunc: validation.StringInSlice([]string{
								string(automation.Windows),
								string(automation.Linux),
							}, false),
							Default: string(automation.Windows),
						},
						"azure_virtual_machines": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"duration": {
							Type:         schema.TypeString,
							Optional:     true,
							ValidateFunc: validateIso8601Duration(),
						},
						"linux": {
							Type:     schema.TypeList,
							Optional: true,
							MaxItems: 1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"excluded_package_name_masks": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"included_package_classifications": {
										Type:     schema.TypeString,
										Optional: true,
										ValidateFunc: validation.StringInSlice([]string{
											string(automation.Unclassified),
											string(automation.Critical),
											string(automation.Security),
											string(automation.Other),
										}, false),
										Default: string(automation.Unclassified),
									},
									"included_package_name_masks": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"reboot_setting": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},
						"non_azure_computer_names": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"targets": {
							Type:     schema.TypeList,
							Optional: true,
							MaxItems: 1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"azure_queries": {
										Type:     schema.TypeList,
										Optional: true,
										MaxItems: 1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"locations": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"scope": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
									"non_azure_queries": {
										Type:     schema.TypeList,
										Optional: true,
										MaxItems: 1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"function_alias": {
													Type:     schema.TypeString,
													Optional: true,
												},
												"workspace_id": {
													Type:     schema.TypeString,
													Optional: true,
												},
											},
										},
									},
								},
							},
						},
						"windows": {
							Type:     schema.TypeList,
							Optional: true,
							MaxItems: 1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"excluded_kb_numbers": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"included_kb_numbers": {
										Type:     schema.TypeString,
										Optional: true,
									},
									"included_update_classifications": {
										Type:     schema.TypeString,
										Optional: true,
										ValidateFunc: validation.StringInSlice([]string{
											string(automation.Unclassified),
											string(automation.Critical),
											string(automation.Security),
											string(automation.UpdateRollup),
											string(automation.FeaturePack),
											string(automation.ServicePack),
											string(automation.Definition),
											string(automation.Tools),
											string(automation.Updates),
										}, false),
										Default: string(automation.Unclassified),
									},
									"reboot_setting": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},
					},
				},
			},

			"client_request_id": {
				Type:     schema.TypeString,
				Optional: true,
				ForceNew: true,
			},

			"error": {
				Type:     schema.TypeList,
				Optional: true,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"code": {
							Type:     schema.TypeString,
							Optional: true,
						},
						"message": {
							Type:     schema.TypeString,
							Optional: true,
						},
					},
				},
			},

			"tasks": {
				Type:     schema.TypeList,
				Optional: true,
				MaxItems: 1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"post_task": {
							Type:     schema.TypeList,
							Optional: true,
							MaxItems: 1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"parameters": {
										Type:     schema.TypeMap,
										Optional: true,
										Elem:     &schema.Schema{Type: schema.TypeString},
									},
									"source": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},
						"pre_task": {
							Type:     schema.TypeList,
							Optional: true,
							MaxItems: 1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"parameters": {
										Type:     schema.TypeMap,
										Optional: true,
										Elem:     &schema.Schema{Type: schema.TypeString},
									},
									"source": {
										Type:     schema.TypeString,
										Optional: true,
									},
								},
							},
						},
					},
				},
			},

			"created_by": {
				Type:     schema.TypeString,
				Computed: true,
			},

			"creation_time": {
				Type:     schema.TypeString,
				Computed: true,
			},

			"last_modified_by": {
				Type:     schema.TypeString,
				Computed: true,
			},

			"last_modified_time": {
				Type:     schema.TypeString,
				Computed: true,
			},

			"provisioning_state": {
				Type:     schema.TypeString,
				Computed: true,
			},

			"type": {
				Type:     schema.TypeString,
				Computed: true,
			},
		},
	}
}

func resourceArmSoftwareUpdateConfigurationCreateUpdate(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*ArmClient).softwareUpdateConfigurationsClient
	ctx := meta.(*ArmClient).StopContext

	name := d.Get("name").(string)
	resourceGroup := d.Get("resource_group").(string)
	automationAccountName := d.Get("automation_account_name").(string)
	clientRequestID := d.Get("client_request_id").(string)

	if features.ShouldResourcesBeImported() && d.IsNewResource() {
		resp, err := client.GetByName(ctx, resourceGroup, automationAccountName, name, clientRequestID)
		if err != nil {
			if !utils.ResponseWasNotFound(resp.Response) {
				return fmt.Errorf("Error checking for present of existing Software Update Configuration %q (Client Request %q / Automation Account Name %q / Resource Group %q): %+v", name, clientRequestID, automationAccountName, resourceGroup, err)
			}
		}
		if !utils.ResponseWasNotFound(resp.Response) {
			return tf.ImportAsExistsError("azurerm_software_update_configuration", *resp.ID)
		}
	}

	error := d.Get("error").([]interface{})
	scheduleInfo := d.Get("schedule_info").([]interface{})
	tasks := d.Get("tasks").([]interface{})
	updateConfiguration := d.Get("update_configuration").([]interface{})

	parameters := automation.softwareUpdateConfiguration{
		Properties: &automation.softwareUpdateConfigurationProperties{
			Error:               expandArmSoftwareUpdateConfigurationErrorResponse(error),
			ScheduleInfo:        expandArmSoftwareUpdateConfigurationScheduleProperties(scheduleInfo),
			Tasks:               expandArmSoftwareUpdateConfigurationsoftwareUpdateConfigurationTasks(tasks),
			UpdateConfiguration: expandArmSoftwareUpdateConfigurationupdateConfiguration(updateConfiguration),
		},
	}

	if _, err := client.Create(ctx, resourceGroup, automationAccountName, name, clientRequestID, parameters); err != nil {
		return fmt.Errorf("Error creating Software Update Configuration %q (Client Request %q / Automation Account Name %q / Resource Group %q): %+v", name, clientRequestID, automationAccountName, resourceGroup, err)
	}

	resp, err := client.GetByName(ctx, resourceGroup, automationAccountName, name, clientRequestID)
	if err != nil {
		return fmt.Errorf("Error retrieving Software Update Configuration %q (Client Request %q / Automation Account Name %q / Resource Group %q): %+v", name, clientRequestID, automationAccountName, resourceGroup, err)
	}
	if resp.ID == nil {
		return fmt.Errorf("Cannot read Software Update Configuration %q (Client Request %q / Automation Account Name %q / Resource Group %q) ID", name, clientRequestID, automationAccountName, resourceGroup)
	}
	d.SetId(*resp.ID)

	return resourceArmSoftwareUpdateConfigurationRead(d, meta)
}

func resourceArmSoftwareUpdateConfigurationRead(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*ArmClient).softwareUpdateConfigurationsClient
	ctx := meta.(*ArmClient).StopContext

	id, err := azure.ParseAzureResourceID(d.Id())
	if err != nil {
		return err
	}
	resourceGroup := id.ResourceGroup
	automationAccountName := id.Path["automationAccounts"]
	name := id.Path["softwareUpdateConfigurations"]

	resp, err := client.GetByName(ctx, resourceGroup, automationAccountName, name, clientRequestID)
	if err != nil {
		if utils.ResponseWasNotFound(resp.Response) {
			log.Printf("[INFO] Software Update Configuration %q does not exist - removing from state", d.Id())
			d.SetId("")
			return nil
		}
		return fmt.Errorf("Error reading Software Update Configuration %q (Client Request %q / Automation Account Name %q / Resource Group %q): %+v", name, clientRequestID, automationAccountName, resourceGroup, err)
	}

	d.Set("name", resp.Name)
	d.Set("name", resp.Name)
	d.Set("name", resp.Name)
	d.Set("name", resp.Name)
	d.Set("resource_group", resourceGroup)
	d.Set("automation_account_name", automationAccountName)
	d.Set("client_request_id", clientRequestID)
	if properties := resp.Properties; properties != nil {
		d.Set("created_by", properties.CreatedBy)
		d.Set("creation_time", (properties.CreationTime).String())
		if err := d.Set("error", flattenArmSoftwareUpdateConfigurationErrorResponse(properties.Error)); err != nil {
			return fmt.Errorf("Error setting `error`: %+v", err)
		}
		d.Set("last_modified_by", properties.LastModifiedBy)
		d.Set("last_modified_time", (properties.LastModifiedTime).String())
		d.Set("provisioning_state", properties.ProvisioningState)
		if err := d.Set("schedule_info", flattenArmSoftwareUpdateConfigurationScheduleProperties(properties.ScheduleInfo)); err != nil {
			return fmt.Errorf("Error setting `schedule_info`: %+v", err)
		}
		if err := d.Set("tasks", flattenArmSoftwareUpdateConfigurationsoftwareUpdateConfigurationTasks(properties.Tasks)); err != nil {
			return fmt.Errorf("Error setting `tasks`: %+v", err)
		}
		if err := d.Set("update_configuration", flattenArmSoftwareUpdateConfigurationupdateConfiguration(properties.UpdateConfiguration)); err != nil {
			return fmt.Errorf("Error setting `update_configuration`: %+v", err)
		}
	}
	d.Set("type", resp.Type)

	return nil
}

func resourceArmSoftwareUpdateConfigurationDelete(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*ArmClient).softwareUpdateConfigurationsClient
	ctx := meta.(*ArmClient).StopContext

	id, err := azure.ParseAzureResourceID(d.Id())
	if err != nil {
		return err
	}
	resourceGroup := id.ResourceGroup
	automationAccountName := id.Path["automationAccounts"]
	name := id.Path["softwareUpdateConfigurations"]

	if _, err := client.Delete(ctx, resourceGroup, automationAccountName, name, clientRequestID); err != nil {
		return fmt.Errorf("Error deleting Software Update Configuration %q (Client Request %q / Automation Account Name %q / Resource Group %q): %+v", name, clientRequestID, automationAccountName, resourceGroup, err)
	}

	return nil
}

func expandArmSoftwareUpdateConfigurationErrorResponse(input []interface{}) *automation.ErrorResponse {
	if len(input) == 0 {
		return nil
	}
	v := input[0].(map[string]interface{})

	code := v["code"].(string)
	message := v["message"].(string)

	result := automation.ErrorResponse{
		Code:    utils.String(code),
		Message: utils.String(message),
	}
	return &result
}

func expandArmSoftwareUpdateConfigurationScheduleProperties(input []interface{}) *automation.ScheduleProperties {
	if len(input) == 0 {
		return nil
	}
	v := input[0].(map[string]interface{})

	startTime := v["start_time"].(string)
	expiryTime := v["expiry_time"].(string)
	expiryTimeOffsetMinutes := v["expiry_time_offset_minutes"].(int)
	isEnabled := v["is_enabled"].(bool)
	nextRun := v["next_run"].(string)
	nextRunOffsetMinutes := v["next_run_offset_minutes"].(int)
	interval := v["interval"].(int)
	frequency := v["frequency"].(string)
	timeZone := v["time_zone"].(string)
	advancedSchedule := v["advanced_schedule"].([]interface{})
	creationTime := v["creation_time"].(string)
	lastModifiedTime := v["last_modified_time"].(string)
	description := v["description"].(string)

	result := automation.ScheduleProperties{
		AdvancedSchedule:        expandArmSoftwareUpdateConfigurationAdvancedSchedule(advancedSchedule),
		CreationTime:            convertStringToDate(creationTime),
		Description:             utils.String(description),
		ExpiryTime:              convertStringToDate(expiryTime),
		ExpiryTimeOffsetMinutes: utils.Int(expiryTimeOffsetMinutes),
		Frequency:               automation.ScheduleFrequency(frequency),
		Interval:                utils.Int(interval),
		IsEnabled:               utils.Bool(isEnabled),
		LastModifiedTime:        convertStringToDate(lastModifiedTime),
		NextRun:                 convertStringToDate(nextRun),
		NextRunOffsetMinutes:    utils.Int(nextRunOffsetMinutes),
		StartTime:               convertStringToDate(startTime),
		TimeZone:                utils.String(timeZone),
	}
	return &result
}

func expandArmSoftwareUpdateConfigurationsoftwareUpdateConfigurationTasks(input []interface{}) *automation.softwareUpdateConfigurationTasks {
	if len(input) == 0 {
		return nil
	}
	v := input[0].(map[string]interface{})

	preTask := v["pre_task"].([]interface{})
	postTask := v["post_task"].([]interface{})

	result := automation.softwareUpdateConfigurationTasks{
		PostTask: expandArmSoftwareUpdateConfigurationtaskProperties(postTask),
		PreTask:  expandArmSoftwareUpdateConfigurationtaskProperties(preTask),
	}
	return &result
}

func expandArmSoftwareUpdateConfigurationupdateConfiguration(input []interface{}) *automation.updateConfiguration {
	if len(input) == 0 {
		return nil
	}
	v := input[0].(map[string]interface{})

	operatingSystem := v["operating_system"].(string)
	windows := v["windows"].([]interface{})
	linux := v["linux"].([]interface{})
	duration := v["duration"].(string)
	azureVirtualMachines := v["azure_virtual_machines"].(string)
	nonAzureComputerNames := v["non_azure_computer_names"].(string)
	targets := v["targets"].([]interface{})

	result := automation.updateConfiguration{
		AzureVirtualMachines:  utils.String(azureVirtualMachines),
		Duration:              utils.String(duration),
		Linux:                 expandArmSoftwareUpdateConfigurationLinuxProperties(linux),
		NonAzureComputerNames: utils.String(nonAzureComputerNames),
		OperatingSystem:       automation.OperatingSystemType(operatingSystem),
		Targets:               expandArmSoftwareUpdateConfigurationTargetProperties(targets),
		Windows:               expandArmSoftwareUpdateConfigurationWindowsProperties(windows),
	}
	return &result
}

func expandArmSoftwareUpdateConfigurationAdvancedSchedule(input []interface{}) *automation.AdvancedSchedule {
	if len(input) == 0 {
		return nil
	}
	v := input[0].(map[string]interface{})

	weekDays := v["week_days"].(string)
	monthDays := v["month_days"].(int)
	monthlyOccurrences := v["monthly_occurrences"].([]interface{})

	result := automation.AdvancedSchedule{
		MonthDays:          utils.Int(monthDays),
		MonthlyOccurrences: expandArmSoftwareUpdateConfigurationAdvancedScheduleMonthlyOccurrence(monthlyOccurrences),
		WeekDays:           utils.String(weekDays),
	}
	return &result
}

func convertStringToDate(input interface{}) *date.Time {
	v := input.(string)

	dateTime, err := date.ParseTime(time.RFC3339, v)
	if err != nil {
		log.Printf("[ERROR] Cannot convert an invalid string to RFC3339 date %q: %+v", v, err)
		return nil
	}

	result := date.Time{
		Time: dateTime,
	}
	return &result
}

func expandArmSoftwareUpdateConfigurationtaskProperties(input []interface{}) *automation.taskProperties {
	if len(input) == 0 {
		return nil
	}
	v := input[0].(map[string]interface{})

	parameters := v["parameters"].(map[string]interface{})
	source := v["source"].(string)

	result := automation.taskProperties{
		Parameters: utils.ExpandKeyValuePairs(parameters),
		Source:     utils.String(source),
	}
	return &result
}

func expandArmSoftwareUpdateConfigurationLinuxProperties(input []interface{}) *automation.LinuxProperties {
	if len(input) == 0 {
		return nil
	}
	v := input[0].(map[string]interface{})

	includedPackageClassifications := v["included_package_classifications"].(string)
	excludedPackageNameMasks := v["excluded_package_name_masks"].(string)
	includedPackageNameMasks := v["included_package_name_masks"].(string)
	rebootSetting := v["reboot_setting"].(string)

	result := automation.LinuxProperties{
		ExcludedPackageNameMasks:       utils.String(excludedPackageNameMasks),
		IncludedPackageClassifications: automation.LinuxUpdateClasses(includedPackageClassifications),
		IncludedPackageNameMasks:       utils.String(includedPackageNameMasks),
		RebootSetting:                  utils.String(rebootSetting),
	}
	return &result
}

func expandArmSoftwareUpdateConfigurationTargetProperties(input []interface{}) *automation.TargetProperties {
	if len(input) == 0 {
		return nil
	}
	v := input[0].(map[string]interface{})

	azureQueries := v["azure_queries"].([]interface{})
	nonAzureQueries := v["non_azure_queries"].([]interface{})

	result := automation.TargetProperties{
		AzureQueries:    expandArmSoftwareUpdateConfigurationAzureQueryProperties(azureQueries),
		NonAzureQueries: expandArmSoftwareUpdateConfigurationNonAzureQueryProperties(nonAzureQueries),
	}
	return &result
}

func expandArmSoftwareUpdateConfigurationWindowsProperties(input []interface{}) *automation.WindowsProperties {
	if len(input) == 0 {
		return nil
	}
	v := input[0].(map[string]interface{})

	includedUpdateClassifications := v["included_update_classifications"].(string)
	excludedKbNumbers := v["excluded_kb_numbers"].(string)
	includedKbNumbers := v["included_kb_numbers"].(string)
	rebootSetting := v["reboot_setting"].(string)

	result := automation.WindowsProperties{
		ExcludedKbNumbers:             utils.String(excludedKbNumbers),
		IncludedKbNumbers:             utils.String(includedKbNumbers),
		IncludedUpdateClassifications: automation.WindowsUpdateClasses(includedUpdateClassifications),
		RebootSetting:                 utils.String(rebootSetting),
	}
	return &result
}

func expandArmSoftwareUpdateConfigurationAdvancedScheduleMonthlyOccurrence(input []interface{}) *automation.AdvancedScheduleMonthlyOccurrence {
	if len(input) == 0 {
		return nil
	}
	v := input[0].(map[string]interface{})

	occurrence := v["occurrence"].(int)
	day := v["day"].(string)

	result := automation.AdvancedScheduleMonthlyOccurrence{
		Day:        automation.ScheduleDay(day),
		Occurrence: utils.Int(occurrence),
	}
	return &result
}

func expandArmSoftwareUpdateConfigurationAzureQueryProperties(input []interface{}) *automation.AzureQueryProperties {
	if len(input) == 0 {
		return nil
	}
	v := input[0].(map[string]interface{})

	scope := v["scope"].(string)
	locations := v["locations"].(string)

	result := automation.AzureQueryProperties{
		Locations: utils.String(locations),
		Scope:     utils.String(scope),
	}
	return &result
}

func expandArmSoftwareUpdateConfigurationNonAzureQueryProperties(input []interface{}) *automation.NonAzureQueryProperties {
	if len(input) == 0 {
		return nil
	}
	v := input[0].(map[string]interface{})

	functionAlias := v["function_alias"].(string)
	workspaceId := v["workspace_id"].(string)

	result := automation.NonAzureQueryProperties{
		FunctionAlias: utils.String(functionAlias),
		WorkspaceID:   utils.String(workspaceId),
	}
	return &result
}

func flattenArmSoftwareUpdateConfigurationErrorResponse(input *automation.ErrorResponse) []interface{} {
	if input == nil {
		return make([]interface{}, 0)
	}

	result := make(map[string]interface{})

	if code := input.Code; code != nil {
		result["code"] = *code
	}
	if message := input.Message; message != nil {
		result["message"] = *message
	}

	return []interface{}{result}
}

func flattenArmSoftwareUpdateConfigurationScheduleProperties(input *automation.ScheduleProperties) []interface{} {
	if input == nil {
		return make([]interface{}, 0)
	}

	result := make(map[string]interface{})

	result["advanced_schedule"] = flattenArmSoftwareUpdateConfigurationAdvancedSchedule(input.AdvancedSchedule)
	if creationTime := input.CreationTime; creationTime != nil {
		result["creation_time"] = (*creationTime).String()
	}
	if description := input.Description; description != nil {
		result["description"] = *description
	}
	if expiryTime := input.ExpiryTime; expiryTime != nil {
		result["expiry_time"] = (*expiryTime).String()
	}
	if expiryTimeOffsetMinutes := input.ExpiryTimeOffsetMinutes; expiryTimeOffsetMinutes != nil {
		result["expiry_time_offset_minutes"] = *expiryTimeOffsetMinutes
	}
	result["frequency"] = string(input.Frequency)
	if interval := input.Interval; interval != nil {
		result["interval"] = *interval
	}
	if isEnabled := input.IsEnabled; isEnabled != nil {
		result["is_enabled"] = *isEnabled
	}
	if lastModifiedTime := input.LastModifiedTime; lastModifiedTime != nil {
		result["last_modified_time"] = (*lastModifiedTime).String()
	}
	if nextRun := input.NextRun; nextRun != nil {
		result["next_run"] = (*nextRun).String()
	}
	if nextRunOffsetMinutes := input.NextRunOffsetMinutes; nextRunOffsetMinutes != nil {
		result["next_run_offset_minutes"] = *nextRunOffsetMinutes
	}
	if startTime := input.StartTime; startTime != nil {
		result["start_time"] = (*startTime).String()
	}
	if timeZone := input.TimeZone; timeZone != nil {
		result["time_zone"] = *timeZone
	}

	return []interface{}{result}
}

func flattenArmSoftwareUpdateConfigurationsoftwareUpdateConfigurationTasks(input *automation.softwareUpdateConfigurationTasks) []interface{} {
	if input == nil {
		return make([]interface{}, 0)
	}

	result := make(map[string]interface{})

	result["post_task"] = flattenArmSoftwareUpdateConfigurationtaskProperties(input.PostTask)
	result["pre_task"] = flattenArmSoftwareUpdateConfigurationtaskProperties(input.PreTask)

	return []interface{}{result}
}

func flattenArmSoftwareUpdateConfigurationupdateConfiguration(input *automation.updateConfiguration) []interface{} {
	if input == nil {
		return make([]interface{}, 0)
	}

	result := make(map[string]interface{})

	if azureVirtualMachines := input.AzureVirtualMachines; azureVirtualMachines != nil {
		result["azure_virtual_machines"] = *azureVirtualMachines
	}
	if duration := input.Duration; duration != nil {
		result["duration"] = *duration
	}
	result["linux"] = flattenArmSoftwareUpdateConfigurationLinuxProperties(input.Linux)
	if nonAzureComputerNames := input.NonAzureComputerNames; nonAzureComputerNames != nil {
		result["non_azure_computer_names"] = *nonAzureComputerNames
	}
	result["operating_system"] = string(input.OperatingSystem)
	result["targets"] = flattenArmSoftwareUpdateConfigurationTargetProperties(input.Targets)
	result["windows"] = flattenArmSoftwareUpdateConfigurationWindowsProperties(input.Windows)

	return []interface{}{result}
}

func flattenArmSoftwareUpdateConfigurationAdvancedSchedule(input *automation.AdvancedSchedule) []interface{} {
	if input == nil {
		return make([]interface{}, 0)
	}

	result := make(map[string]interface{})

	if monthDays := input.MonthDays; monthDays != nil {
		result["month_days"] = *monthDays
	}
	result["monthly_occurrences"] = flattenArmSoftwareUpdateConfigurationAdvancedScheduleMonthlyOccurrence(input.MonthlyOccurrences)
	if weekDays := input.WeekDays; weekDays != nil {
		result["week_days"] = *weekDays
	}

	return []interface{}{result}
}

func flattenArmSoftwareUpdateConfigurationtaskProperties(input *automation.taskProperties) []interface{} {
	if input == nil {
		return make([]interface{}, 0)
	}

	result := make(map[string]interface{})

	result["parameters"] = utils.FlattenKeyValuePairs(input.Parameters)
	if source := input.Source; source != nil {
		result["source"] = *source
	}

	return []interface{}{result}
}

func flattenArmSoftwareUpdateConfigurationLinuxProperties(input *automation.LinuxProperties) []interface{} {
	if input == nil {
		return make([]interface{}, 0)
	}

	result := make(map[string]interface{})

	if excludedPackageNameMasks := input.ExcludedPackageNameMasks; excludedPackageNameMasks != nil {
		result["excluded_package_name_masks"] = *excludedPackageNameMasks
	}
	result["included_package_classifications"] = string(input.IncludedPackageClassifications)
	if includedPackageNameMasks := input.IncludedPackageNameMasks; includedPackageNameMasks != nil {
		result["included_package_name_masks"] = *includedPackageNameMasks
	}
	if rebootSetting := input.RebootSetting; rebootSetting != nil {
		result["reboot_setting"] = *rebootSetting
	}

	return []interface{}{result}
}

func flattenArmSoftwareUpdateConfigurationTargetProperties(input *automation.TargetProperties) []interface{} {
	if input == nil {
		return make([]interface{}, 0)
	}

	result := make(map[string]interface{})

	result["azure_queries"] = flattenArmSoftwareUpdateConfigurationAzureQueryProperties(input.AzureQueries)
	result["non_azure_queries"] = flattenArmSoftwareUpdateConfigurationNonAzureQueryProperties(input.NonAzureQueries)

	return []interface{}{result}
}

func flattenArmSoftwareUpdateConfigurationWindowsProperties(input *automation.WindowsProperties) []interface{} {
	if input == nil {
		return make([]interface{}, 0)
	}

	result := make(map[string]interface{})

	if excludedKbNumbers := input.ExcludedKbNumbers; excludedKbNumbers != nil {
		result["excluded_kb_numbers"] = *excludedKbNumbers
	}
	if includedKbNumbers := input.IncludedKbNumbers; includedKbNumbers != nil {
		result["included_kb_numbers"] = *includedKbNumbers
	}
	result["included_update_classifications"] = string(input.IncludedUpdateClassifications)
	if rebootSetting := input.RebootSetting; rebootSetting != nil {
		result["reboot_setting"] = *rebootSetting
	}

	return []interface{}{result}
}

func flattenArmSoftwareUpdateConfigurationAdvancedScheduleMonthlyOccurrence(input *automation.AdvancedScheduleMonthlyOccurrence) []interface{} {
	if input == nil {
		return make([]interface{}, 0)
	}

	result := make(map[string]interface{})

	result["day"] = string(input.Day)
	if occurrence := input.Occurrence; occurrence != nil {
		result["occurrence"] = *occurrence
	}

	return []interface{}{result}
}

func flattenArmSoftwareUpdateConfigurationAzureQueryProperties(input *automation.AzureQueryProperties) []interface{} {
	if input == nil {
		return make([]interface{}, 0)
	}

	result := make(map[string]interface{})

	if locations := input.Locations; locations != nil {
		result["locations"] = *locations
	}
	if scope := input.Scope; scope != nil {
		result["scope"] = *scope
	}

	return []interface{}{result}
}

func flattenArmSoftwareUpdateConfigurationNonAzureQueryProperties(input *automation.NonAzureQueryProperties) []interface{} {
	if input == nil {
		return make([]interface{}, 0)
	}

	result := make(map[string]interface{})

	if functionAlias := input.FunctionAlias; functionAlias != nil {
		result["function_alias"] = *functionAlias
	}
	if workspaceId := input.WorkspaceID; workspaceId != nil {
		result["workspace_id"] = *workspaceId
	}

	return []interface{}{result}
}
